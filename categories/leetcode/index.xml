<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>LeetCode - Category - TyrangYang_Blog</title><link>https://tyrangyang.github.io/TyrangYang_blog/categories/leetcode/</link><description>LeetCode - Category - TyrangYang_Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 31 Jan 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://tyrangyang.github.io/TyrangYang_blog/categories/leetcode/" rel="self" type="application/rss+xml"/><item><title>Learn from leetCode</title><link>https://tyrangyang.github.io/TyrangYang_blog/leetcode-idea/</link><pubDate>Fri, 31 Jan 2020 00:00:00 +0000</pubDate><author>Haolin Yang</author><guid>https://tyrangyang.github.io/TyrangYang_blog/leetcode-idea/</guid><description><![CDATA[Some strategy learning from leetCode
C++ 2d array Better use a vector(don&rsquo;t need to consider allocator)
int row = 10; int col = 10; int init = 1; vector&lt;vector &lt;int&gt;&gt; memos(row, vector&lt;int&gt;(col, init)) // init can ignore int** a = new int*[rowCount]; for(int i = 0; i &lt; rowCount; ++i) a[i] = new int[colCount]; delete ... Traverse a tree The tree structure:
struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; BFS DFS Pre-order In-order Post-order for a tree Loop for BFS:]]></description></item></channel></rss>