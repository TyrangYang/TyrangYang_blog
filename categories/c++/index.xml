<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>C&#43;&#43; - Category - TyrangYang_Blog</title>
        <link>https://tyrangyang.github.io/TyrangYang_blog/categories/c&#43;&#43;/</link>
        <description>C&#43;&#43; - Category - TyrangYang_Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 01 Mar 2020 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://tyrangyang.github.io/TyrangYang_blog/categories/c&#43;&#43;/" rel="self" type="application/rss+xml" /><item>
    <title>Structured binding</title>
    <link>https://tyrangyang.github.io/TyrangYang_blog/structured-binding/</link>
    <pubDate>Sun, 01 Mar 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://tyrangyang.github.io/TyrangYang_blog/structured-binding/</guid>
    <description><![CDATA[Structured binding is a new feature since c++17
cppreference.com
auto [ identifier-list ] = expression
Bind array 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int main(int argc, char const *argv[]) { int test[3] = {1, 2, 3}; auto [a, b, c] = test; // an new array e copy from test and a = e[0]; b = e[1]; c = e[2]; auto &amp;[x, y, z] = test; // x = test[0]; x = test[1]; x = test[2] cout &lt;&lt; ++a &lt;&lt; &#34; &#34; &lt;&lt; ++b &lt;&lt; &#34; &#34; &lt;&lt; ++c &lt;&lt; &#34; &#34; &lt;&lt; endl; for (int &amp;i : test) cout &lt;&lt; i &lt;&lt; &#34; &#34;; cout &lt;&lt; endl; cout &lt;&lt; ++x &lt;&lt; &#34; &#34; &lt;&lt; ++y &lt;&lt; &#34; &#34; &lt;&lt; ++z &lt;&lt; &#34; &#34; &lt;&lt; endl; for (int &amp;i : test) cout &lt;&lt; i &lt;&lt; &#34; &#34;; cout &lt;&lt; endl; return 0; } tuple 1 2 3 4 5 6 7 8 9 10 11 12 int main(int argc, char const *argv[]) { tuple&lt;int, int, int&gt; test(1, 2, 3); auto &amp;[a, b, c] = test; // 1 2 3 pair&lt;int, char&gt; test2(1, &#39;c&#39;); auto &amp;[a2, b2] = test2; // 1 c return 0; } struct 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 struct test { int a; int b; }; int main(int argc, char const *argv[]) { test one; one.]]></description>
</item><item>
    <title>Lambda in C&#43;&#43;</title>
    <link>https://tyrangyang.github.io/TyrangYang_blog/lambda-cpp/</link>
    <pubDate>Sun, 26 Jan 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://tyrangyang.github.io/TyrangYang_blog/lambda-cpp/</guid>
    <description><![CDATA[Introduction of Lambda expression in C++ and how to use it.
What is Lambda in C++ Lambda expression is a new feature since c++11. It is used to create anonymous function object to simplify programming process.
How Lambda expressions are composed [capture](parameters) mutable -&gt; return type {statement}
1 2 3 4 // ... #include &lt;functional&gt; // ... std:function&lt;int(int, int)&gt; add = [](int a, int b) -&gt; int {return a+b;}; capture Capture variables from context.]]></description>
</item><item>
    <title>explicit and implicit in c&#43;&#43;</title>
    <link>https://tyrangyang.github.io/TyrangYang_blog/explicit-and-implicit/</link>
    <pubDate>Thu, 25 Jul 2019 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://tyrangyang.github.io/TyrangYang_blog/explicit-and-implicit/</guid>
    <description><![CDATA[explicit and implicit In C++, constructor can be explicit and implicit.
The reserve word explicit affect constructor with only one parameter or only one parameter without given initial value.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include &lt;iostream&gt; using namespace std; class test1 { int data; public: test1(int t = 0):data(t){}; ~test1(){}; test1 operator + (const test1 &amp;a) const{ return test1(data + a.]]></description>
</item></channel>
</rss>
