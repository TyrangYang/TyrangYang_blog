<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Traverse a Tree - Tag - TyrangYang_Blog</title><link>https://tyrangyang.github.io/TyrangYang_blog/tags/traverse-a-tree/</link><description>Traverse a Tree - Tag - TyrangYang_Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 10 Feb 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://tyrangyang.github.io/TyrangYang_blog/tags/traverse-a-tree/" rel="self" type="application/rss+xml"/><item><title>Traverse a tree</title><link>https://tyrangyang.github.io/TyrangYang_blog/traverse-a-tree/</link><pubDate>Mon, 10 Feb 2020 00:00:00 +0000</pubDate><author>Haolin Yang</author><guid>https://tyrangyang.github.io/TyrangYang_blog/traverse-a-tree/</guid><description><![CDATA[Idea to traverse a tree
Tree structure The tree structure:
struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; BFS DFS Pre-order In-order Post-order Relationship:
Iterative Loop for BFS:
void BFS(TreeNode *root){ stack&lt;TreeNode *&gt; q; q.push(root); while(!q.empty()){ TreeNode *temp = q.front(); q.pop(); // do something if(temp-&gt;left != NULL) q.push(temp -&gt; left); if(temp-&gt;right != NULL) q.push(temp -&gt; right); } } Loop for DFS:]]></description></item></channel></rss>