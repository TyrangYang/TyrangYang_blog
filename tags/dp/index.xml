<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Dp - Tag - TyrangYang_Blog</title><link>https://tyrangyang.github.io/TyrangYang_blog/tags/dp/</link><description>Dp - Tag - TyrangYang_Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 10 Jul 2020 18:49:03 -0400</lastBuildDate><atom:link href="https://tyrangyang.github.io/TyrangYang_blog/tags/dp/" rel="self" type="application/rss+xml"/><item><title>Dynamic Programming Example</title><link>https://tyrangyang.github.io/TyrangYang_blog/dp-example/</link><pubDate>Fri, 10 Jul 2020 18:49:03 -0400</pubDate><author>xxxx</author><guid>https://tyrangyang.github.io/TyrangYang_blog/dp-example/</guid><description>Longest common subsequence This is a typical recursive problem. The pseudocode is:
If S1[i] == S2[j], lcs(S1[i:],S2[j:]) = 1 + lcs(S1[i+1:],S2[j+1:]) else lcs(S1[i:],S2[j:]) = max(lcs(S1[i:],S2[j+1:]), lcs(S1[i+1s:],S2[j:])) Recursive solution: int longestCommonSubsequence(string text1, string text2) { if(text1.size() == 0 || text2.size() == 0 ){ return 0; } if(text1[0] == text2[0]){ return 1 + longestCommonSubsequence(text1.substr(1, text1.size()-1), text2.substr(1, text1.size()-1)); } return max(longestCommonSubsequence(text1, text2.substr(1, text1.size()-1)), longestCommonSubsequence(text1.substr(1, text1.size()-1), text2)); } Time complexity: O(2^n) Using dp could store the state that already calculate before.</description></item><item><title>Dynamic Programming üèó</title><link>https://tyrangyang.github.io/TyrangYang_blog/dp/</link><pubDate>Fri, 10 Jul 2020 18:41:10 -0400</pubDate><author>xxxx</author><guid>https://tyrangyang.github.io/TyrangYang_blog/dp/</guid><description>What is dp problem DP problem is a programming strategy which use extra space to save time. These problems need to store some state instead of calculate again. For most situation, DP is a strategy to reduce the time consuming for recursive problem.
Memorization Tabulation fibonacci example The classic recursive problem:
const fib = (n) =&amp;gt; { if (n &amp;lt;= 2) return 1; return fib(n - 1) + fib(n - 2); }; How to memorize :</description></item></channel></rss>