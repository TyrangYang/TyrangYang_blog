<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>c&#43;&#43; on TyrangYang_Blog</title>
    <link>https://tyrangyang.github.io/TyrangYang_blog/tags/c&#43;&#43;/</link>
    <description>Recent content in c&#43;&#43; on TyrangYang_Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 20 Sep 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://tyrangyang.github.io/TyrangYang_blog/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>All algorithm in C&#43;&#43;</title>
      <link>https://tyrangyang.github.io/TyrangYang_blog/all-algorithm/</link>
      <pubDate>Fri, 20 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://tyrangyang.github.io/TyrangYang_blog/all-algorithm/</guid>
      <description>Content  Content  Algorithm Overview  Copy  For each  Generation  Heap  Merge  Move  Number  Partition  Permutation  Remove  Replace  Reverse  rotate  Search  Set  Shuffle  Sort  Swap  Test range  Unique   Algorithm Overview * &amp;ndash;&amp;gt; new feature from C++11
   Algorithm Name Usage Mutating? Head File Complexity     accumulate  Accumulate values in range N numeric O(n)   adjacent_difference  Compute adjacent difference of range and return to another place N numeric O(n)   adjacent_find  Find first equal adjacent elements in range N algorithm O(n)   all_of*  Test condition on all elements in range N algorithm O(n)   any_of*  Test if any element in range fulfills condition N algorithm O(n)   binary_search  Test if value exists in sorted sequence N algorithm On average O(logn + 2).</description>
    </item>
    
    <item>
      <title>Algorithm feature in c&#43;&#43; STL</title>
      <link>https://tyrangyang.github.io/TyrangYang_blog/algorithm-feature/</link>
      <pubDate>Sun, 25 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://tyrangyang.github.io/TyrangYang_blog/algorithm-feature/</guid>
      <description>See all algorithm click here  Mutating and Non-mutating algorithms Mutating algorithms Mutating algorithms means this algorithm will change the content that iterator pointed to. Like copy, swap, replace, fill, remove, permutation, partition, random shuffling and sort.
If your give these algorithms a const iterator, only error will be returned.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  #include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std; int main(int argc, char const *argv[]) { std::vector&amp;lt;int&amp;gt; iv = {22,30,30,17,33,40,17,23,22,12,20}; vector&amp;lt;int&amp;gt;::iterator ib = iv.</description>
    </item>
    
    <item>
      <title>Bit operation in C&#43;&#43;</title>
      <link>https://tyrangyang.github.io/TyrangYang_blog/c-bit-operation/</link>
      <pubDate>Sun, 18 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://tyrangyang.github.io/TyrangYang_blog/c-bit-operation/</guid>
      <description>Bit operator    operator function example     &amp;laquo; left shift 0001 &amp;ndash;&amp;gt; 0010   &amp;raquo; right shift 0010 &amp;ndash;&amp;gt; 0001   &amp;amp; and (bit by bit) 1100 &amp;amp; 1010 = 1000   | or (bit by bit) 1010 | 0101 = 1111   ~ reverse ~0000 = 1111   ^ XOR 0110 ^ 1100 = 1010    Operator: &amp;amp; x is a bit</description>
    </item>
    
    <item>
      <title>RB tree</title>
      <link>https://tyrangyang.github.io/TyrangYang_blog/rb-tree/</link>
      <pubDate>Sat, 17 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://tyrangyang.github.io/TyrangYang_blog/rb-tree/</guid>
      <description>2-3 tree &amp;amp; 2-4 tree 2-node: 1 key and 2 children 3-node: 2 keys and 3 children 4-node: 3 keys and 4 children
A (2,4) tree (also called 2-4 tree or 2-3-4 tree) is a multi-way search with the following properties:
 Node-Size Property: every internal node has at most four children Depth Property: all the external nodes have the same depth  insertion deletion 2-4 tree ==&amp;gt; RB tree If break down 3-node and 4-node, 2-4 tree will become RB tree.</description>
    </item>
    
    <item>
      <title>Operator overwrite in c&#43;&#43;</title>
      <link>https://tyrangyang.github.io/TyrangYang_blog/operator-overwrite/</link>
      <pubDate>Tue, 13 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://tyrangyang.github.io/TyrangYang_blog/operator-overwrite/</guid>
      <description>Example increment and decrement operator
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72  #include &amp;lt;iostream&amp;gt;using namespace std; class INT { private: int m_i; public: INT(int i):m_i(i){}; friend bool operator==(INT&amp;amp; test1, INT&amp;amp; test2){ return test1.</description>
    </item>
    
    <item>
      <title>Container in c&#43;&#43;</title>
      <link>https://tyrangyang.github.io/TyrangYang_blog/containers/</link>
      <pubDate>Wed, 31 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://tyrangyang.github.io/TyrangYang_blog/containers/</guid>
      <description>Classification  Sequence container  array (build in) vector  heap  priority queue  list  slist (not standard) deque  stack (adopter) queue (adopter)   Associative container  RB-tree (not public) set  map  multiset multemap hashtable (not standard) hash_set (not standard) hash_map (not standard) hash_multimap (not standard) hash_multiset (not standard)    Associative container have a key-value pair. It do not have back and front so they never have push_back, pop_back.</description>
    </item>
    
    <item>
      <title>explicit and implicit in c&#43;&#43;</title>
      <link>https://tyrangyang.github.io/TyrangYang_blog/explicit-and-implicit/</link>
      <pubDate>Thu, 25 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://tyrangyang.github.io/TyrangYang_blog/explicit-and-implicit/</guid>
      <description>explicit and implicit In C++, constructor can be explicit and implicit.
The reserve word explicit affect constructor with only one parameter or only one parameter without given initial value.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  #include &amp;lt;iostream&amp;gt;using namespace std; class test1 { int data; public: test1(int t = 0):data(t){}; ~test1(){}; test1 operator + (const test1 &amp;amp;a) const{ return test1(data + a.</description>
    </item>
    
    <item>
      <title>Iterator in c&#43;&#43;</title>
      <link>https://tyrangyang.github.io/TyrangYang_blog/iterators/</link>
      <pubDate>Wed, 24 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://tyrangyang.github.io/TyrangYang_blog/iterators/</guid>
      <description>Iterator 设计思维 STL 中 container 和 algorithm 是相对独立的，本身设计也是泛型化的。Iterator 就是用来将这两者联系在一起的。
Iterator 是一种 smart pointer 可以不用 delete
Iterator 属性 iterator_traits 是用来抽取 iterator 中的类型(特指 value type)的。
这是 iterator 中常见的五种属性。
1 2 3 4 5 6 7 8 9  template &amp;lt;class I&amp;gt; struct iterator_traits { typedef typename I::iterator_category iterator_category; //category  typedef typename I::value_type value_type; // type  typedef typename I::difference_type difference_type; //  typedef typename I::pointer pointer; // T*  typedef typename I::reference reference; // T&amp;amp; };   1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include &amp;lt;iostream&amp;gt; // std::cout#include &amp;lt;iterator&amp;gt; // std::iterator_traits#include &amp;lt;typeinfo&amp;gt; // typeidusing namespace std; int main() { typedef std::iterator_traits&amp;lt;double*&amp;gt; traits; cout &amp;lt;&amp;lt; typeid(traits::iterator_category).</description>
    </item>
    
    <item>
      <title>Allocator in c&#43;&#43;</title>
      <link>https://tyrangyang.github.io/TyrangYang_blog/allocator/</link>
      <pubDate>Sun, 21 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://tyrangyang.github.io/TyrangYang_blog/allocator/</guid>
      <description>Allocator is for memory 配置内存空间 -&amp;gt; 构建(constructor) -&amp;gt; 解构(destructor) -&amp;gt; 释放内存空间
construct() and destroy() 用于建构和解构
Memory allocate and release 双层配置器。第一级是区块大于 128 bytes 的，使用 malloc()和 free()。第二级是区块小于 128 bytes 的，使用 memory pool 和 freelist。
第一級配置器 第一級配置器以 malloc(), free(), realloc() 等 C 函式執行實際的記憶體配置、釋放、重配置動作，並實作出類似 C++ new-handler7 機制。是的，它不能直接運用 C++ new-handler 機制，因為它並非使用 ::operator new 來配置記 憶體。
所謂 C++ new handler 機制是，你可以要求系統在記憶體配置需求無法被滿足時， 喚起一個你所指定的函式。換句話說一旦 ::operator new 無法達成任務，在丟出 std::bad_alloc 異常狀態之前，會先呼叫由客端指定的處理常式。此處理常式 通常即被稱為 new-handler。new-handler 解決記憶體不足的作法有特定的模式。
注意，SGI 以 malloc 而非 ::operator new 來配置記憶體(我所能夠想像的一 個原因是歷史因素，另一個原因是 C++ 並未提供相應於 realloc() 的記憶體配 置動作)，因此 SGI 不能直接使用 C++ 的 set_new_handler()，必須模擬一個 類似的 set_malloc_handler()。</description>
    </item>
    
    <item>
      <title>Functor in C&#43;&#43;</title>
      <link>https://tyrangyang.github.io/TyrangYang_blog/functor/</link>
      <pubDate>Sat, 20 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://tyrangyang.github.io/TyrangYang_blog/functor/</guid>
      <description>Basically, Functor have same functionality with interface in java.
Think about this code. You want count all string whose length is less than 5.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;string&amp;gt;using namespace std; bool lenLessThanFive(const string&amp;amp; str){ return str.size() &amp;lt; 5; } int main(int argc, char const *argv[]) { string ia[5] = {&amp;#34;a&amp;#34;, &amp;#34;aa&amp;#34;, &amp;#34;aaa&amp;#34;, &amp;#34;aaaa&amp;#34;, &amp;#34;aaaaa&amp;#34;}; vector&amp;lt;string&amp;gt; iv(ia, ia+5); int res = count_if(iv.</description>
    </item>
    
    <item>
      <title>Common method comparison - c&#43;&#43; &amp; java</title>
      <link>https://tyrangyang.github.io/TyrangYang_blog/language-comparison-common-method/</link>
      <pubDate>Fri, 12 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://tyrangyang.github.io/TyrangYang_blog/language-comparison-common-method/</guid>
      <description>Sort C++ For c++, here is official document sort() This method sorts elements in the range [first, last).
Result is in ascending order by deflaut.
Introsort.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  // sort algorithm example #include &amp;lt;iostream&amp;gt; // std::cout#include &amp;lt;algorithm&amp;gt; // std::sort#include &amp;lt;vector&amp;gt; // std::vector bool myfunction (int i,int j) { return (i&amp;gt;j); } int main () { int myints[] = {32,71,12,45,26,80,53,33}; std::vector&amp;lt;int&amp;gt; myvector (myints, myints+8); // 32 71 12 45 26 80 53 33  // using default comparison (operator &amp;lt;):  std::sort (myvector.</description>
    </item>
    
    <item>
      <title>Container comparison - c&#43;&#43; &amp; java</title>
      <link>https://tyrangyang.github.io/TyrangYang_blog/language-comparison-containor/</link>
      <pubDate>Thu, 11 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://tyrangyang.github.io/TyrangYang_blog/language-comparison-containor/</guid>
      <description>Container comparison C++ version is c++11. Java version is java se8.
   C++ JAVA Description     array / [ ] [ ] 固定大小的数组   vector ArrayList 可变长度的数组    Vector 可变长度的数组，支持同步操作，效率比 ArrayList 略差   list LinkedList 双链表，便于增删   forward_list  单链表，c++没有给他提供 size()的方法   deque ArrayDeque 双向队列   stack Stack 栈，先进后出   queue Queue 队，先进先出   priority_queue PriorityQueue 支持优先级的队列   set TreeSet 集合，数据有序，红黑树   unordered_set HashSet 集合，数据无序，hash   map TreeMap key-value 映射，key 有序，红黑树   unordered_map HashMap map, 无序，hash   multiset  集合，允许重复元素   multimap  map，允许重复的 key   unordered_multiset  无序允许重复元素集合   unordered_multimap  无序允许重复 key 的 map    LinkedHashSet 按照插入顺序，支持 hash 查找    LinkedHashMap 按照插入顺序，支持 hash 查找    HashTable 类似 HashMap，效率略低   bitset BitSet 位操作    HashTable &amp;amp; HashMap The HashMap class is roughly equivalent to Hashtable, except that it is asynchronized and permits nulls.</description>
    </item>
    
  </channel>
</rss>