<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>C++ - Tag - TyrangYang_Blog</title><link>https://tyrangyang.github.io/TyrangYang_blog/tags/c++/</link><description>C++ - Tag - TyrangYang_Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 10 Jul 2020 18:49:03 -0400</lastBuildDate><atom:link href="https://tyrangyang.github.io/TyrangYang_blog/tags/c++/" rel="self" type="application/rss+xml"/><item><title>Dynamic Programming Example</title><link>https://tyrangyang.github.io/TyrangYang_blog/dp-example/</link><pubDate>Fri, 10 Jul 2020 18:49:03 -0400</pubDate><author>xxxx</author><guid>https://tyrangyang.github.io/TyrangYang_blog/dp-example/</guid><description>Longest common subsequence This is a typical recursive problem. The pseudocode is:
If S1[i] == S2[j], lcs(S1[i:],S2[j:]) = 1 + lcs(S1[i+1:],S2[j+1:]) else lcs(S1[i:],S2[j:]) = max(lcs(S1[i:],S2[j+1:]), lcs(S1[i+1s:],S2[j:])) Recursive solution: int longestCommonSubsequence(string text1, string text2) { if(text1.size() == 0 || text2.size() == 0 ){ return 0; } if(text1[0] == text2[0]){ return 1 + longestCommonSubsequence(text1.substr(1, text1.size()-1), text2.substr(1, text1.size()-1)); } return max(longestCommonSubsequence(text1, text2.substr(1, text1.size()-1)), longestCommonSubsequence(text1.substr(1, text1.size()-1), text2)); } Time complexity: O(2^n) Using dp could store the state that already calculate before.</description></item><item><title>Dynamic Programming üèó</title><link>https://tyrangyang.github.io/TyrangYang_blog/dp/</link><pubDate>Fri, 10 Jul 2020 18:41:10 -0400</pubDate><author>xxxx</author><guid>https://tyrangyang.github.io/TyrangYang_blog/dp/</guid><description>What is dp problem DP problem is a programming strategy which use extra space to save time. These problems need to store some state instead of calculate again. For most situation, DP is a strategy to reduce the time consuming for recursive problem.
Memorization Tabulation fibonacci example The classic recursive problem:
const fib = (n) =&amp;gt; { if (n &amp;lt;= 2) return 1; return fib(n - 1) + fib(n - 2); }; How to memorize :</description></item><item><title>Structured binding</title><link>https://tyrangyang.github.io/TyrangYang_blog/structured-binding/</link><pubDate>Sun, 01 Mar 2020 00:00:00 +0000</pubDate><author>Haolin Yang</author><guid>https://tyrangyang.github.io/TyrangYang_blog/structured-binding/</guid><description><![CDATA[Structured binding is a new feature since c++17
cppreference.com
auto [ identifier-list ] = expression
Bind array int main(int argc, char const *argv[]) { int test[3] = {1, 2, 3}; auto [a, b, c] = test; // an new array e copy from test and a = e[0]; b = e[1]; c = e[2]; auto &amp;[x, y, z] = test; // x = test[0]; x = test[1]; x = test[2] cout &lt;&lt; ++a &lt;&lt; &#34; &#34; &lt;&lt; ++b &lt;&lt; &#34; &#34; &lt;&lt; ++c &lt;&lt; &#34; &#34; &lt;&lt; endl; for (int &amp;i : test) cout &lt;&lt; i &lt;&lt; &#34; &#34;; cout &lt;&lt; endl; cout &lt;&lt; ++x &lt;&lt; &#34; &#34; &lt;&lt; ++y &lt;&lt; &#34; &#34; &lt;&lt; ++z &lt;&lt; &#34; &#34; &lt;&lt; endl; for (int &amp;i : test) cout &lt;&lt; i &lt;&lt; &#34; &#34;; cout &lt;&lt; endl; return 0; } tuple int main(int argc, char const *argv[]) { tuple&lt;int, int, int&gt; test(1, 2, 3); auto &amp;[a, b, c] = test; // 1 2 3 pair&lt;int, char&gt; test2(1, &#39;c&#39;); auto &amp;[a2, b2] = test2; // 1 c return 0; } struct struct test { int a; int b; }; int main(int argc, char const *argv[]) { test one; one.]]></description></item><item><title>How to find next permutation</title><link>https://tyrangyang.github.io/TyrangYang_blog/next-permutation/</link><pubDate>Wed, 05 Feb 2020 00:00:00 +0000</pubDate><author>Haolin Yang</author><guid>https://tyrangyang.github.io/TyrangYang_blog/next-permutation/</guid><description><![CDATA[This is introduce how to find the next lexicographically permutation.
Suppose the permutation is 1 2 3. The next one is 1 3 2.
Algorithm in C++ C++ provide an algorithm called next_permutation to support that. Reference
Example:
#include &lt;iostream&gt; // std::cout #include &lt;algorithm&gt; // std::next_permutation, std::sort int main () { int myints[] = {1,2,3}; std::sort (myints,myints+3); std::cout &lt;&lt; &#34;The 3! possible permutations with 3 elements:\n&#34;; do { std::cout &lt;&lt; myints[0] &lt;&lt; &#39; &#39; &lt;&lt; myints[1] &lt;&lt; &#39; &#39; &lt;&lt; myints[2] &lt;&lt; &#39;\n&#39;; } while ( std::next_permutation(myints,myints+3) ); std::cout &lt;&lt; &#34;After loop: &#34; &lt;&lt; myints[0] &lt;&lt; &#39; &#39; &lt;&lt; myints[1] &lt;&lt; &#39; &#39; &lt;&lt; myints[2] &lt;&lt; &#39;\n&#39;; return 0; How it work.]]></description></item><item><title>Lambda in C++</title><link>https://tyrangyang.github.io/TyrangYang_blog/lambda-cpp/</link><pubDate>Sun, 26 Jan 2020 00:00:00 +0000</pubDate><author>Haolin Yang</author><guid>https://tyrangyang.github.io/TyrangYang_blog/lambda-cpp/</guid><description><![CDATA[Introduction of Lambda expression in C++ and how to use it.
What is Lambda in C++ Lambda expression is a new feature since c++11. It is used to create anonymous function object to simplify programming process.
How Lambda expressions are composed [capture](parameters) mutable -&gt; return type {statement}
// ... #include &lt;functional&gt; // ... std:function&lt;int(int, int)&gt; add = [](int a, int b) -&gt; int {return a+b;}; capture Capture variables from context.]]></description></item><item><title>All algorithm in C++</title><link>https://tyrangyang.github.io/TyrangYang_blog/all-algorithm/</link><pubDate>Fri, 20 Sep 2019 00:00:00 +0000</pubDate><author>Haolin Yang</author><guid>https://tyrangyang.github.io/TyrangYang_blog/all-algorithm/</guid><description>Content Content Algorithm Overview Copy For each Generation Heap Merge Move Number Partition Permutation Remove Replace Reverse rotate Search Set Shuffle Sort Swap Test range Unique Algorithm Overview * &amp;ndash;&amp;gt; new feature from C++11
Algorithm Name Usage Mutating? Head File Complexity accumulate Accumulate values in range N numeric O(n) adjacent_difference Compute adjacent difference of range and return to another place N numeric O(n) adjacent_find Find first equal adjacent elements in range N algorithm O(n) all_of* Test condition on all elements in range N algorithm O(n) any_of* Test if any element in range fulfills condition N algorithm O(n) binary_search Test if value exists in sorted sequence N algorithm On average O(logn + 2).</description></item><item><title>Algorithm feature in c++ STL</title><link>https://tyrangyang.github.io/TyrangYang_blog/algorithm-feature/</link><pubDate>Sun, 25 Aug 2019 00:00:00 +0000</pubDate><author>Haolin Yang</author><guid>https://tyrangyang.github.io/TyrangYang_blog/algorithm-feature/</guid><description><![CDATA[See all algorithm click here Mutating and Non-mutating algorithms Mutating algorithms Mutating algorithms means this algorithm will change the content that iterator pointed to. Like copy, swap, replace, fill, remove, permutation, partition, random shuffling and sort.
If your give these algorithms a const iterator, only error will be returned.
#include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main(int argc, char const *argv[]) { std::vector&lt;int&gt; iv = {22,30,30,17,33,40,17,23,22,12,20}; vector&lt;int&gt;::iterator ib = iv.]]></description></item><item><title>Bit operation in C++</title><link>https://tyrangyang.github.io/TyrangYang_blog/cpp-bit-operation/</link><pubDate>Sun, 18 Aug 2019 00:00:00 +0000</pubDate><author>Haolin Yang</author><guid>https://tyrangyang.github.io/TyrangYang_blog/cpp-bit-operation/</guid><description><![CDATA[Bit operator operator function example &laquo; left shift 0001 &ndash;&gt; 0010 &raquo; right shift 0010 &ndash;&gt; 0001 &amp; and (bit by bit) 1100 &amp; 1010 = 1000 | or (bit by bit) 1010 | 0101 = 1111 ~ reverse ~0000 = 1111 ^ XOR 0110 ^ 1100 = 1010 Operator: &amp; x is a bit
x &amp; 1 = x
x &amp; 0 = 0
Usually use &amp; as a filter.]]></description></item><item><title>RB tree</title><link>https://tyrangyang.github.io/TyrangYang_blog/rb-tree/</link><pubDate>Sat, 17 Aug 2019 00:00:00 +0000</pubDate><author>Haolin Yang</author><guid>https://tyrangyang.github.io/TyrangYang_blog/rb-tree/</guid><description>2-3 tree &amp;amp; 2-4 tree 2-node: 1 key and 2 children 3-node: 2 keys and 3 children 4-node: 3 keys and 4 children
A (2,4) tree (also called 2-4 tree or 2-3-4 tree) is a multi-way search with the following properties:
Node-Size Property: every internal node has at most four children Depth Property: all the external nodes have the same depth insertion deletion 2-4 tree ==&amp;gt; RB tree If break down 3-node and 4-node, 2-4 tree will become RB tree.</description></item><item><title>Operator overwrite in c++</title><link>https://tyrangyang.github.io/TyrangYang_blog/operator-overwrite/</link><pubDate>Tue, 13 Aug 2019 00:00:00 +0000</pubDate><author>Haolin Yang</author><guid>https://tyrangyang.github.io/TyrangYang_blog/operator-overwrite/</guid><description><![CDATA[Example increment and decrement operator
#include &lt;iostream&gt; using namespace std; class INT { private: int m_i; public: INT(int i):m_i(i){}; friend bool operator==(INT&amp; test1, INT&amp; test2){ return test1.m_i == test2.m_i; } friend bool operator!=(INT&amp; test1, INT&amp; test2){ return test1.m_i != test2.m_i; } friend INT operator+(INT&amp; test1, INT&amp; test2){ int temp = test1.m_i + test2.m_i; INT res(temp); return res; } INT&amp; operator=(INT&amp; test){ this-&gt;m_i = test.m_i; return *this; } int&amp; operator*() const{ return (int&amp;)this-&gt;m_i; } // int a() const {}; This means a() cannot change any member in class.]]></description></item></channel></rss>