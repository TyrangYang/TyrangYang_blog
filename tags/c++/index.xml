<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>c&#43;&#43; | Tag | TyrangYang_Blog</title>
        <link>https://tyrangyang.github.io/TyrangYang_blog/tags/c&#43;&#43;/</link>
        <description>c&#43;&#43; | Tag | TyrangYang_Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 01 Mar 2020 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://tyrangyang.github.io/TyrangYang_blog/tags/c&#43;&#43;/" rel="self" type="application/rss+xml" /><item>
                <title>Structured binding</title>
                <link>https://tyrangyang.github.io/TyrangYang_blog/structured-binding/</link>
                <pubDate>Sun, 01 Mar 2020 00:00:00 &#43;0000</pubDate>
                <author>Haolin Yang</author>
                <guid>https://tyrangyang.github.io/TyrangYang_blog/structured-binding/</guid>
                <description>Structured binding is a new feature since c&#43;&#43;17
cppreference.com
auto [ identifier-list ] = expression
Bind array 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  int main(int argc, char const *argv[]) { int test[3] = {1, 2, 3}; auto [a, b, c] = test; // an new array e copy from test and a = e[0]; b = e[1]; c = e[2]; 	auto &amp;amp;[x, y, z] = test; // x = test[0]; x = test[1]; x = test[2]  cout &amp;lt;&amp;lt; &#43;&#43;a &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; &#43;&#43;b &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; &#43;&#43;c &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; endl; for (int &amp;amp;i : test) cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#34; &amp;#34;; cout &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &#43;&#43;x &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; &#43;&#43;y &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; &#43;&#43;z &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; endl; for (int &amp;amp;i : test) cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#34; &amp;#34;; cout &amp;lt;&amp;lt; endl; return 0; }   tuple 1 2 3 4 5 6 7 8 9 10 11 12  int main(int argc, char const *argv[]) { tuple&amp;lt;int, int, int&amp;gt; test(1, 2, 3); auto &amp;amp;[a, b, c] = test; // 1 2 3  pair&amp;lt;int, char&amp;gt; test2(1, &amp;#39;c&amp;#39;); auto &amp;amp;[a2, b2] = test2; // 1 c  return 0; }   struct 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  struct test { int a; int b; }; int main(int argc, char const *argv[]) { test one; one.</description>
            </item><item>
                <title>How to find next permutation</title>
                <link>https://tyrangyang.github.io/TyrangYang_blog/next-permutation/</link>
                <pubDate>Wed, 05 Feb 2020 00:00:00 &#43;0000</pubDate>
                <author>Haolin Yang</author>
                <guid>https://tyrangyang.github.io/TyrangYang_blog/next-permutation/</guid>
                <description>This is introduce how to find the next lexicographically permutation.
Suppose the permutation is 1 2 3. The next one is 1 3 2.
Algorithm in C&#43;&#43; C&#43;&#43; provide an algorithm called next_permutation to support that. Reference
Example:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #include &amp;lt;iostream&amp;gt; // std::cout#include &amp;lt;algorithm&amp;gt; // std::next_permutation, std::sort int main () { int myints[] = {1,2,3}; std::sort (myints,myints&#43;3); std::cout &amp;lt;&amp;lt; &amp;#34;The 3!</description>
            </item><item>
                <title>Lambda in C&#43;&#43;</title>
                <link>https://tyrangyang.github.io/TyrangYang_blog/lambda-cpp/</link>
                <pubDate>Sun, 26 Jan 2020 00:00:00 &#43;0000</pubDate>
                <author>Haolin Yang</author>
                <guid>https://tyrangyang.github.io/TyrangYang_blog/lambda-cpp/</guid>
                <description>Introduction of Lambda expression in C&#43;&#43; and how to use it.
What is Lambda in C&#43;&#43; Lambda expression is a new feature since c&#43;&#43;11. It is used to create anonymous function object to simplify programming process.
How Lambda expressions are composed [capture](parameters) mutable -&amp;gt; return type {statement}
1 2 3 4  // ... #include &amp;lt;functional&amp;gt;// ... std:function&amp;lt;int(int, int)&amp;gt; add = [](int a, int b) -&amp;gt; int {return a&#43;b;};   capture Capture variables from context.</description>
            </item><item>
                <title>All algorithm in C&#43;&#43;</title>
                <link>https://tyrangyang.github.io/TyrangYang_blog/all-algorithm/</link>
                <pubDate>Fri, 20 Sep 2019 00:00:00 &#43;0000</pubDate>
                <author>Haolin Yang</author>
                <guid>https://tyrangyang.github.io/TyrangYang_blog/all-algorithm/</guid>
                <description>Content  Content Algorithm Overview Copy For each Generation Heap Merge Move Number Partition Permutation Remove Replace Reverse rotate Search Set Shuffle Sort Swap Test range Unique  Algorithm Overview * &amp;ndash;&amp;gt; new feature from C&#43;&#43;11
   Algorithm Name Usage Mutating? Head File Complexity     accumulate Accumulate values in range N numeric O(n)   adjacent_difference Compute adjacent difference of range and return to another place N numeric O(n)   adjacent_find Find first equal adjacent elements in range N algorithm O(n)   all_of* Test condition on all elements in range N algorithm O(n)   any_of* Test if any element in range fulfills condition N algorithm O(n)   binary_search Test if value exists in sorted sequence N algorithm On average O(logn &#43; 2).</description>
            </item><item>
                <title>Algorithm feature in c&#43;&#43; STL</title>
                <link>https://tyrangyang.github.io/TyrangYang_blog/algorithm-feature/</link>
                <pubDate>Sun, 25 Aug 2019 00:00:00 &#43;0000</pubDate>
                <author>Haolin Yang</author>
                <guid>https://tyrangyang.github.io/TyrangYang_blog/algorithm-feature/</guid>
                <description>See all algorithm click here Mutating and Non-mutating algorithms Mutating algorithms Mutating algorithms means this algorithm will change the content that iterator pointed to. Like copy, swap, replace, fill, remove, permutation, partition, random shuffling and sort.
If your give these algorithms a const iterator, only error will be returned.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  #include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std; int main(int argc, char const *argv[]) { std::vector&amp;lt;int&amp;gt; iv = {22,30,30,17,33,40,17,23,22,12,20}; vector&amp;lt;int&amp;gt;::iterator ib = iv.</description>
            </item><item>
                <title>Bit operation in C&#43;&#43;</title>
                <link>https://tyrangyang.github.io/TyrangYang_blog/c-bit-operation/</link>
                <pubDate>Sun, 18 Aug 2019 00:00:00 &#43;0000</pubDate>
                <author>Haolin Yang</author>
                <guid>https://tyrangyang.github.io/TyrangYang_blog/c-bit-operation/</guid>
                <description>Bit operator    operator function example     &amp;laquo; left shift 0001 &amp;ndash;&amp;gt; 0010   &amp;raquo; right shift 0010 &amp;ndash;&amp;gt; 0001   &amp;amp; and (bit by bit) 1100 &amp;amp; 1010 = 1000   | or (bit by bit) 1010 | 0101 = 1111   ~ reverse ~0000 = 1111   ^ XOR 0110 ^ 1100 = 1010    Operator: &amp;amp; x is a bit</description>
            </item><item>
                <title>RB tree</title>
                <link>https://tyrangyang.github.io/TyrangYang_blog/rb-tree/</link>
                <pubDate>Sat, 17 Aug 2019 00:00:00 &#43;0000</pubDate>
                <author>Haolin Yang</author>
                <guid>https://tyrangyang.github.io/TyrangYang_blog/rb-tree/</guid>
                <description>2-3 tree &amp;amp; 2-4 tree 2-node: 1 key and 2 children 3-node: 2 keys and 3 children 4-node: 3 keys and 4 children
A (2,4) tree (also called 2-4 tree or 2-3-4 tree) is a multi-way search with the following properties:
 Node-Size Property: every internal node has at most four children Depth Property: all the external nodes have the same depth  insertion deletion 2-4 tree ==&amp;gt; RB tree If break down 3-node and 4-node, 2-4 tree will become RB tree.</description>
            </item><item>
                <title>Operator overwrite in c&#43;&#43;</title>
                <link>https://tyrangyang.github.io/TyrangYang_blog/operator-overwrite/</link>
                <pubDate>Tue, 13 Aug 2019 00:00:00 &#43;0000</pubDate>
                <author>Haolin Yang</author>
                <guid>https://tyrangyang.github.io/TyrangYang_blog/operator-overwrite/</guid>
                <description>Example increment and decrement operator
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72  #include &amp;lt;iostream&amp;gt;using namespace std; class INT { private: int m_i; public: INT(int i):m_i(i){}; friend bool operator==(INT&amp;amp; test1, INT&amp;amp; test2){ return test1.</description>
            </item><item>
                <title>Container in c&#43;&#43;</title>
                <link>https://tyrangyang.github.io/TyrangYang_blog/containers/</link>
                <pubDate>Wed, 31 Jul 2019 00:00:00 &#43;0000</pubDate>
                <author>Haolin Yang</author>
                <guid>https://tyrangyang.github.io/TyrangYang_blog/containers/</guid>
                <description>Classification  Sequence container  array (build in) vector heap priority queue list slist (not standard) deque stack (adopter) queue (adopter)   Associative container  RB-tree (not public) set map multiset multemap hashtable (not standard) hash_set (not standard) hash_map (not standard) hash_multimap (not standard) hash_multiset (not standard)    Associative container have a key-value pair. It do not have back and front so they never have push_back, pop_back.</description>
            </item><item>
                <title>explicit and implicit in c&#43;&#43;</title>
                <link>https://tyrangyang.github.io/TyrangYang_blog/explicit-and-implicit/</link>
                <pubDate>Thu, 25 Jul 2019 00:00:00 &#43;0000</pubDate>
                <author>Haolin Yang</author>
                <guid>https://tyrangyang.github.io/TyrangYang_blog/explicit-and-implicit/</guid>
                <description>explicit and implicit In C&#43;&#43;, constructor can be explicit and implicit.
The reserve word explicit affect constructor with only one parameter or only one parameter without given initial value.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  #include &amp;lt;iostream&amp;gt;using namespace std; class test1 { int data; public: test1(int t = 0):data(t){}; ~test1(){}; test1 operator &#43; (const test1 &amp;amp;a) const{ return test1(data &#43; a.</description>
            </item></channel>
</rss>
