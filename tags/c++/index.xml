<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>c&#43;&#43; - Tag - TyrangYang_Blog</title>
        <link>https://tyrangyang.github.io/TyrangYang_blog/tags/c&#43;&#43;/</link>
        <description>c&#43;&#43; - Tag - TyrangYang_Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 10 Jul 2020 18:49:03 -0400</lastBuildDate><atom:link href="https://tyrangyang.github.io/TyrangYang_blog/tags/c&#43;&#43;/" rel="self" type="application/rss+xml" /><item>
    <title>Dynamic Programming Example</title>
    <link>https://tyrangyang.github.io/TyrangYang_blog/dp-example/</link>
    <pubDate>Fri, 10 Jul 2020 18:49:03 -0400</pubDate>
    <author>Author</author>
    <guid>https://tyrangyang.github.io/TyrangYang_blog/dp-example/</guid>
    <description><![CDATA[Longest common subsequence This is a typical recursive problem. The pseudocode is:
1 2  If S1[i] == S2[j], lcs(S1[i:],S2[j:]) = 1 + lcs(S1[i+1:],S2[j+1:]) else lcs(S1[i:],S2[j:]) = max(lcs(S1[i:],S2[j+1:]), lcs(S1[i+1s:],S2[j:]))   Recursive solution: 1 2 3 4 5 6 7 8 9 10 11 12  int longestCommonSubsequence(string text1, string text2) { if(text1.size() == 0 || text2.size() == 0 ){ return 0; } if(text1[0] == text2[0]){ return 1 + longestCommonSubsequence(text1.substr(1, text1.]]></description>
</item><item>
    <title>Dynamic Programming üèó</title>
    <link>https://tyrangyang.github.io/TyrangYang_blog/dp/</link>
    <pubDate>Fri, 10 Jul 2020 18:41:10 -0400</pubDate>
    <author>Author</author>
    <guid>https://tyrangyang.github.io/TyrangYang_blog/dp/</guid>
    <description><![CDATA[What is dp problem DP problem is a programming strategy which use extra space to save time. These problems need to store some state instead of calculate again. For most situation, DP is a strategy to reduce the time consuming for recursive problem.
 Memorization Tabulation  fibonacci example The classic recursive problem:
1 2 3 4  const fib = (n) =&gt; { if (n &lt;= 2) return 1; return fib(n - 1) + fib(n - 2); };   How to memorize :]]></description>
</item><item>
    <title>Structured binding</title>
    <link>https://tyrangyang.github.io/TyrangYang_blog/structured-binding/</link>
    <pubDate>Sun, 01 Mar 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://tyrangyang.github.io/TyrangYang_blog/structured-binding/</guid>
    <description><![CDATA[Structured binding is a new feature since c++17
cppreference.com
auto [ identifier-list ] = expression
Bind array 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  int main(int argc, char const *argv[]) { int test[3] = {1, 2, 3}; auto [a, b, c] = test; // an new array e copy from test and a = e[0]; b = e[1]; c = e[2]; 	auto &amp;[x, y, z] = test; // x = test[0]; x = test[1]; x = test[2]  cout &lt;&lt; ++a &lt;&lt; &#34; &#34; &lt;&lt; ++b &lt;&lt; &#34; &#34; &lt;&lt; ++c &lt;&lt; &#34; &#34; &lt;&lt; endl; for (int &amp;i : test) cout &lt;&lt; i &lt;&lt; &#34; &#34;; cout &lt;&lt; endl; cout &lt;&lt; ++x &lt;&lt; &#34; &#34; &lt;&lt; ++y &lt;&lt; &#34; &#34; &lt;&lt; ++z &lt;&lt; &#34; &#34; &lt;&lt; endl; for (int &amp;i : test) cout &lt;&lt; i &lt;&lt; &#34; &#34;; cout &lt;&lt; endl; return 0; }   tuple 1 2 3 4 5 6 7 8 9 10 11 12  int main(int argc, char const *argv[]) { tuple&lt;int, int, int&gt; test(1, 2, 3); auto &amp;[a, b, c] = test; // 1 2 3  pair&lt;int, char&gt; test2(1, &#39;c&#39;); auto &amp;[a2, b2] = test2; // 1 c  return 0; }   struct 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  struct test { int a; int b; }; int main(int argc, char const *argv[]) { test one; one.]]></description>
</item><item>
    <title>How to find next permutation</title>
    <link>https://tyrangyang.github.io/TyrangYang_blog/next-permutation/</link>
    <pubDate>Wed, 05 Feb 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://tyrangyang.github.io/TyrangYang_blog/next-permutation/</guid>
    <description><![CDATA[This is introduce how to find the next lexicographically permutation.
Suppose the permutation is 1 2 3. The next one is 1 3 2.
Algorithm in C++ C++ provide an algorithm called next_permutation to support that. Reference
Example:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #include &lt;iostream&gt; // std::cout#include &lt;algorithm&gt; // std::next_permutation, std::sort int main () { int myints[] = {1,2,3}; std::sort (myints,myints+3); std::cout &lt;&lt; &#34;The 3!]]></description>
</item><item>
    <title>Lambda in C&#43;&#43;</title>
    <link>https://tyrangyang.github.io/TyrangYang_blog/lambda-cpp/</link>
    <pubDate>Sun, 26 Jan 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://tyrangyang.github.io/TyrangYang_blog/lambda-cpp/</guid>
    <description><![CDATA[Introduction of Lambda expression in C++ and how to use it.
What is Lambda in C++ Lambda expression is a new feature since c++11. It is used to create anonymous function object to simplify programming process.
How Lambda expressions are composed [capture](parameters) mutable -&gt; return type {statement}
1 2 3 4  // ... #include &lt;functional&gt;// ... std:function&lt;int(int, int)&gt; add = [](int a, int b) -&gt; int {return a+b;};   capture Capture variables from context.]]></description>
</item><item>
    <title>All algorithm in C&#43;&#43;</title>
    <link>https://tyrangyang.github.io/TyrangYang_blog/all-algorithm/</link>
    <pubDate>Fri, 20 Sep 2019 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://tyrangyang.github.io/TyrangYang_blog/all-algorithm/</guid>
    <description><![CDATA[Content  Content Algorithm Overview Copy For each Generation Heap Merge Move Number Partition Permutation Remove Replace Reverse rotate Search Set Shuffle Sort Swap Test range Unique  Algorithm Overview * &ndash;&gt; new feature from C++11
   Algorithm Name Usage Mutating? Head File Complexity     accumulate Accumulate values in range N numeric O(n)   adjacent_difference Compute adjacent difference of range and return to another place N numeric O(n)   adjacent_find Find first equal adjacent elements in range N algorithm O(n)   all_of* Test condition on all elements in range N algorithm O(n)   any_of* Test if any element in range fulfills condition N algorithm O(n)   binary_search Test if value exists in sorted sequence N algorithm On average O(logn + 2).]]></description>
</item><item>
    <title>Algorithm feature in c&#43;&#43; STL</title>
    <link>https://tyrangyang.github.io/TyrangYang_blog/algorithm-feature/</link>
    <pubDate>Sun, 25 Aug 2019 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://tyrangyang.github.io/TyrangYang_blog/algorithm-feature/</guid>
    <description><![CDATA[See all algorithm click here Mutating and Non-mutating algorithms Mutating algorithms Mutating algorithms means this algorithm will change the content that iterator pointed to. Like copy, swap, replace, fill, remove, permutation, partition, random shuffling and sort.
If your give these algorithms a const iterator, only error will be returned.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  #include &lt;iostream&gt;#include &lt;vector&gt;using namespace std; int main(int argc, char const *argv[]) { std::vector&lt;int&gt; iv = {22,30,30,17,33,40,17,23,22,12,20}; vector&lt;int&gt;::iterator ib = iv.]]></description>
</item><item>
    <title>Bit operation in C&#43;&#43;</title>
    <link>https://tyrangyang.github.io/TyrangYang_blog/cpp-bit-operation/</link>
    <pubDate>Sun, 18 Aug 2019 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://tyrangyang.github.io/TyrangYang_blog/cpp-bit-operation/</guid>
    <description><![CDATA[Bit operator    operator function example     &laquo; left shift 0001 &ndash;&gt; 0010   &raquo; right shift 0010 &ndash;&gt; 0001   &amp; and (bit by bit) 1100 &amp; 1010 = 1000   | or (bit by bit) 1010 | 0101 = 1111   ~ reverse ~0000 = 1111   ^ XOR 0110 ^ 1100 = 1010    Operator: &amp; x is a bit]]></description>
</item><item>
    <title>RB tree</title>
    <link>https://tyrangyang.github.io/TyrangYang_blog/rb-tree/</link>
    <pubDate>Sat, 17 Aug 2019 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://tyrangyang.github.io/TyrangYang_blog/rb-tree/</guid>
    <description><![CDATA[2-3 tree &amp; 2-4 tree 2-node: 1 key and 2 children 3-node: 2 keys and 3 children 4-node: 3 keys and 4 children
A (2,4) tree (also called 2-4 tree or 2-3-4 tree) is a multi-way search with the following properties:
 Node-Size Property: every internal node has at most four children Depth Property: all the external nodes have the same depth  insertion deletion 2-4 tree ==&gt; RB tree If break down 3-node and 4-node, 2-4 tree will become RB tree.]]></description>
</item><item>
    <title>Operator overwrite in c&#43;&#43;</title>
    <link>https://tyrangyang.github.io/TyrangYang_blog/operator-overwrite/</link>
    <pubDate>Tue, 13 Aug 2019 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://tyrangyang.github.io/TyrangYang_blog/operator-overwrite/</guid>
    <description><![CDATA[Example increment and decrement operator
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72  #include &lt;iostream&gt;using namespace std; class INT { private: int m_i; public: INT(int i):m_i(i){}; friend bool operator==(INT&amp; test1, INT&amp; test2){ return test1.]]></description>
</item></channel>
</rss>
