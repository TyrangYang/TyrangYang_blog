<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>algorithm - Tag - TyrangYang_Blog</title>
        <link>https://tyrangyang.github.io/TyrangYang_blog/tags/algorithm/</link>
        <description>algorithm - Tag - TyrangYang_Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 05 Feb 2020 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://tyrangyang.github.io/TyrangYang_blog/tags/algorithm/" rel="self" type="application/rss+xml" /><item>
    <title>How to find next permutation</title>
    <link>https://tyrangyang.github.io/TyrangYang_blog/next-permutation/</link>
    <pubDate>Wed, 05 Feb 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://tyrangyang.github.io/TyrangYang_blog/next-permutation/</guid>
    <description><![CDATA[This is introduce how to find the next lexicographically permutation.
Suppose the permutation is 1 2 3. The next one is 1 3 2.
Algorithm in C++ C++ provide an algorithm called next_permutation to support that. Reference
Example:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #include &lt;iostream&gt; // std::cout#include &lt;algorithm&gt; // std::next_permutation, std::sort int main () { int myints[] = {1,2,3}; std::sort (myints,myints+3); std::cout &lt;&lt; &#34;The 3!]]></description>
</item><item>
    <title>DFS &amp; BFS</title>
    <link>https://tyrangyang.github.io/TyrangYang_blog/dfs-bfs/</link>
    <pubDate>Tue, 14 Jan 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://tyrangyang.github.io/TyrangYang_blog/dfs-bfs/</guid>
    <description><![CDATA[DFS &amp; BFS are two basic algorithms to traverse a graph(or a tree). DFS is Deep-first search and BFS is Breath-first search.
Basic idea The idea behind two algorithms are identical but use different auxiliary data structure. DFS use stack and BFS use Queue.
First, Every node have a mark to identify is already be visited or not(it could be a list or an attribute in node).
Second, Push the start point into the auxiliary data structure and loop until structure is empty.]]></description>
</item><item>
    <title>Miller Rabin Algorithm</title>
    <link>https://tyrangyang.github.io/TyrangYang_blog/miller-rabin/</link>
    <pubDate>Mon, 13 Jan 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://tyrangyang.github.io/TyrangYang_blog/miller-rabin/</guid>
    <description><![CDATA[What is millerRabin algorithm The Miller–Rabin primality test or Rabin–Miller primality test is a primality test: an algorithm which determines whether a given number is prime, similar to the Fermat primality test and the Solovay–Strassen primality test. It was first discovered by Russian mathematician M. M. Artjuhov in 1967.[1] Gary L. Miller rediscovered it in 1976; Miller&rsquo;s version of the test is deterministic, but its correctness relies on the unproven extended Riemann hypothesis.]]></description>
</item><item>
    <title>All algorithm in C&#43;&#43;</title>
    <link>https://tyrangyang.github.io/TyrangYang_blog/all-algorithm/</link>
    <pubDate>Fri, 20 Sep 2019 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://tyrangyang.github.io/TyrangYang_blog/all-algorithm/</guid>
    <description><![CDATA[Content  Content Algorithm Overview Copy For each Generation Heap Merge Move Number Partition Permutation Remove Replace Reverse rotate Search Set Shuffle Sort Swap Test range Unique  Algorithm Overview * &ndash;&gt; new feature from C++11
   Algorithm Name Usage Mutating? Head File Complexity     accumulate Accumulate values in range N numeric O(n)   adjacent_difference Compute adjacent difference of range and return to another place N numeric O(n)   adjacent_find Find first equal adjacent elements in range N algorithm O(n)   all_of* Test condition on all elements in range N algorithm O(n)   any_of* Test if any element in range fulfills condition N algorithm O(n)   binary_search Test if value exists in sorted sequence N algorithm On average O(logn + 2).]]></description>
</item><item>
    <title>Algorithm feature in c&#43;&#43; STL</title>
    <link>https://tyrangyang.github.io/TyrangYang_blog/algorithm-feature/</link>
    <pubDate>Sun, 25 Aug 2019 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://tyrangyang.github.io/TyrangYang_blog/algorithm-feature/</guid>
    <description><![CDATA[See all algorithm click here Mutating and Non-mutating algorithms Mutating algorithms Mutating algorithms means this algorithm will change the content that iterator pointed to. Like copy, swap, replace, fill, remove, permutation, partition, random shuffling and sort.
If your give these algorithms a const iterator, only error will be returned.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  #include &lt;iostream&gt;#include &lt;vector&gt;using namespace std; int main(int argc, char const *argv[]) { std::vector&lt;int&gt; iv = {22,30,30,17,33,40,17,23,22,12,20}; vector&lt;int&gt;::iterator ib = iv.]]></description>
</item></channel>
</rss>
